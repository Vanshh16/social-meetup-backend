// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/config/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

model User {
  id           String  @id @default(uuid())
  name         String // Display Name (required)
  mobileNumber String  @unique
  email        String @unique
  password   String? // Hashed password
  isVerified Boolean @default(false) // Verification status
  googleId       String?     @unique
  authMethod     AuthMethod
  profilePhoto   String? // URL or base64 image path
  gender         Gender? // Enum
  dateOfBirth    DateTime? // Used to calculate age group
  whatsappNumber String?  @unique // Optional
  aadhaarNumber  String? // Masked before display (store full securely)
  religion       Religion? // Enum
  city           String? // From GPS or manual entry
  referralCode     String?   @unique
  referredById     String?
  pictures       String[]
  fcmTokens      String[]

  // Optional fields
  relationshipStatus RelationshipStatus?
  bio                String?             @db.VarChar(200)
  hobbies            String[] // Array of tags/hobbies

  // Role
  role        Role    @default(USER)
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Meetup Meetup[]

  JoinRequest JoinRequest[]

  Chat Chat[] @relation("ChatUsers")

   UserWallet     UserWallet?

  Message Message[]

  reportsMade     UserReport[] @relation("ReportedBy")
  reportsAgainst  UserReport[] @relation("ReportsAgainst")

  blocked         UserBlock[]  @relation("BlockedBy")
  blockedBy       UserBlock[]  @relation("BlockedUsers")
  isSuspended      Boolean         @default(false)
  UserSuspensions  SuspensionLog[] @relation("UserSuspensions")
  AdminActions     SuspensionLog[] @relation("AdminActions")

  @@index([referredById])
  Payment Payment[]
  Notification Notification[]
}

enum AuthMethod {
  MOBILE_OTP
  GOOGLE
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum Religion {
  HINDU
  MUSLIM
  SIKH
  CHRISTIAN
  JAIN
  BUDDHIST
  PARSI
  OTHER
}

enum RelationshipStatus {
  SINGLE
  IN_RELATIONSHIP
  MARRIED
  COMPLICATED
}

model Meetup {
  id               String   @id @default(uuid())
  category         String
  subcategory      String?
  locationName     String?   // A descriptive name for the location (e.g., "Cafe Coffee Day")
  latitude         Float     // The latitude coordinate
  longitude        Float
  type             String   // "instant" | "planned"
  date             DateTime?
  time             String?  // store as string like "18:30" if planned
  preferredAgeMin  Int?
  preferredAgeMax  Int?
  preferredGender  String?  // "male" | "female" | "any"
  preferredReligion String?
  groupSize        Int      // 1 for single, >1 for group
  distanceRangeKm  Int?

  createdBy        String
  user             User     @relation(fields: [createdBy], references: [id])
  createdAt        DateTime @default(now())

  JoinRequest JoinRequest[]

  Chat Chat[]

  @@index([createdBy])
  @@index([category])
}

model JoinRequest {
  id         String   @id @default(uuid())
  meetupId   String
  meetup     Meetup   @relation(fields: [meetupId], references: [id])

  senderId   String
  sender     User     @relation(fields: [senderId], references: [id])

  status     RequestStatus @default(PENDING)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  Payment    Payment?

  @@index([meetupId])
  @@index([senderId])
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

model Payment {
  id            String   @id @default(uuid())
  
  // --- ADD THIS FIELD ---
  userId          String?  // The user this payment belongs to
  user            User?    @relation(fields: [userId], references: [id])
  
  joinRequestId String?  @unique // Now optional 
  joinRequest   JoinRequest? @relation(fields: [joinRequestId], references: [id])
  
  meetupId      String?  // Add optional relation to Meetup
  
  purpose       String   // e.g., "MEETUP_CREATION" or "JOIN_REQUEST"
  amount        Int
  status        PaymentStatus @default(PENDING)

  cashfreeOrderId String?  @unique
  paymentSessionId String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum ChatType {
  ONE_ON_ONE
  GROUP
}

model Chat {
  id        String    @id @default(uuid())
  name      String?   // For group chat names, e.g., "Weekend Trip Group"
  meetupId  String    @unique // A meetup should only have one chat
  meetup    Meetup    @relation(fields: [meetupId], references: [id])
  type      ChatType
  users     User[]    @relation("ChatUsers")
  messages  Message[]
  createdAt DateTime  @default(now())
}

enum MessageType {
  TEXT
  IMAGE
  VOICE
}

model Message {
  id        String   @id @default(uuid())
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id])
  senderId  String
  sender    User     @relation(fields: [senderId], references: [id])
  content   String
  type      MessageType @default(TEXT)
  createdAt DateTime @default(now())
}

// Add these new models to your schema.prisma file

model Category {
  id          String       @id @default(uuid())
  name        String       @unique
  subcategories SubCategory[]
  price         Float       @default(0.0)
}

model SubCategory {
  id         String   @id @default(uuid())
  name       String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
}

model UserWallet {
  id            String    @id @default(uuid())
  userId        String    @unique
  user          User      @relation(fields: [userId], references: [id])
  balance       Float     @default(0.0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  transactions  WalletTransaction[]
}

model WalletTransaction {
  id          String   @id @default(uuid())
  walletId    String
  wallet      UserWallet @relation(fields: [walletId], references: [id])
  amount      Float
  type        TransactionType
  description String
  createdAt   DateTime @default(now())
}

enum TransactionType {
  CREDIT  // Manual credit by admin
  DEBIT   // Withdrawal or spending by user/admin
  REWARD  // Automated or manual reward (e.g., referral)
}

model AppSettings {
  id    String @id @default(uuid())
  key   String @unique // e.g., "REFERRAL_REWARD_AMOUNT"
  value String
}

enum ReportReason {
  SPAM
  INAPPROPRIATE_CONTENT
  HARASSMENT
  SCAM
  OTHER
}

enum ReportStatus {
  PENDING     // What your frontend calls "NEW"
  IN_PROGRESS // What your frontend calls "IN PROGRESS"
  RESOLVED    // What your frontend calls "RESOLVED"
  DISMISSED   // What your frontend calls "FALSE REPORTS"
}

// --- NEW: Add this enum ---
enum SuspensionAction {
  SUSPEND
  UNSUSPEND
}

// --- NEW: Add this model ---
model SuspensionLog {
  id        String           @id @default(uuid())
  
  // The user who was suspended/unsuspended
  userId    String
  user      User             @relation("UserSuspensions", fields: [userId], references: [id])
  
  // The admin who performed the action
  adminId   String
  admin     User             @relation("AdminActions", fields: [adminId], references: [id])
  
  action    SuspensionAction // SUSPEND or UNSUSPEND
  reason    String?          @db.Text
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([adminId])
}

model UserReport {
  id          String       @id @default(uuid())
  reason      ReportReason
  status      ReportStatus @default(PENDING)
  details     String?      @db.Text

  reporterId  String
  reporter    User         @relation("ReportedBy", fields: [reporterId], references: [id])

  reportedId  String
  reported    User         @relation("ReportsAgainst", fields: [reportedId], references: [id])

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt @default(now())

  @@index([reporterId])
  @@index([reportedId])
  @@index([status])
}

model UserBlock {
  blockerId String
  blocker   User   @relation("BlockedBy", fields: [blockerId], references: [id])

  blockedId String
  blocked   User   @relation("BlockedUsers", fields: [blockedId], references: [id])

  createdAt DateTime @default(now())

  @@id([blockerId, blockedId]) // Composite key to prevent duplicate blocks
}

model Banner {
  id        String   @id @default(uuid())
  title     String
  imageUrl  String   // URL of the banner image from Cloudinary
  isActive  Boolean  @default(true) // To easily enable/disable banners
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  vibeMatch
  eventNearby
  profileLike
  joinRequest
  message
  other
}

model Notification {
  id           String           @id @default(uuid())
  userId       String           // The ID of the user who will receive this
  user         User             @relation(fields: [userId], references: [id])
  type         NotificationType
  title        String
  subtitle     String           @db.Text // Use @db.Text for longer descriptions
  isRead       Boolean          @default(false)
  
  // Optional fields from your spec
  icon         String?
  iconColor    String?
  profileImage String?          // URL of the sender's image
  senderName   String?          // Name of the sender
  data         Json?            // For storing extra data, e.g., { "meetupId": "..." }

  createdAt    DateTime         @default(now())

  @@index([userId, isRead]) // Index for fast fetching of user's unread notifications
}